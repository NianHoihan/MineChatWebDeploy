# Function calling (Tools) — OpenAI API

给模型接入**外部功能与数据**，让它在生成回复时主动**调用你的工具/函数**。本页整理了要点、完整示例、流式事件与自定义语法约束。

---

## 核心概念

- **Tool / Function（工具 / 函数）**：你暴露给模型的能力。例：`get_weather(location)`、`refund(order_id)`、`lookup_user(user_id)` 等。
- **Tool call（工具调用）**：模型在思考后认为需要外部能力，会返回一个**调用请求**（包含工具名与参数）。
- **Tool call output（工具返回）**：你的后端执行工具后得到的结果（文本或 JSON），再带着**call_id**回传给模型，模型据此完成最终回答。

> 术语：**Function 是 Tool 的一种**（以 JSON Schema 定义参数）。此外还有**自定义工具**（自由文本输入/输出），以及平台**内置工具**（web 搜索、代码执行、MCP 服务器等）。

---

## 标准调用流程（5 步）

1. **请求**：携带可用的 `tools` 列表向模型发起请求。  
2. **接收调用**：模型返回一个或多个 `function_call` / `custom_tool_call`。  
3. **执行工具**：你的后端根据调用参数实际执行代码或外部 API。  
4. **回传结果**：把**工具定义 + 原始输入 + 模型的 tool call + 你的工具输出**一并再发给模型。  
5. **完成回复**：模型利用工具返回给出最终答案（或继续发起更多调用）。

> 对 **推理模型**（如 GPT‑5、o4‑mini）：若响应中含有 *reasoning items*，在回传工具结果时也要**原样带回**这些条目。

---

## 完整示例（Function Tool）

以下示例为「星座运势」函数：模型先决定是否调用，再把结果拼进最终回答。

### Python

```python
from openai import OpenAI
import json

client = OpenAI()

# 1) 定义工具（函数）
tools = [
    {
        "type": "function",
        "name": "get_horoscope",
        "description": "Get today's horoscope for an astrological sign.",
        "parameters": {
            "type": "object",
            "properties": {
                "sign": {
                    "type": "string",
                    "description": "An astrological sign like Taurus or Aquarius",
                },
            },
            "required": ["sign"],
            "additionalProperties": False
        },
        "strict": True,
    },
]

# 维护一份对话输入（会逐步追加）
input_list = [
    {"role": "user", "content": "What is my horoscope? I am an Aquarius."}
]

# 2) 向模型发起请求（包含 tools）
response = client.responses.create(
    model="gpt-5",
    tools=tools,
    input=input_list,
)

# 提取 function_call
function_call = None
function_call_arguments = None
input_list += response.output

for item in response.output:
    if item.type == "function_call":
        function_call = item
        function_call_arguments = json.loads(item.arguments)

def get_horoscope(sign):
    return f"{sign}: Next Tuesday you will befriend a baby otter."

# 3) 执行函数
result = {"horoscope": get_horoscope(function_call_arguments["sign"])}

# 4) 回传工具调用结果
input_list.append({
    "type": "function_call_output",
    "call_id": function_call.call_id,
    "output": json.dumps(result),
})

# 5) 让模型生成最终答复（可加入明确指令）
final = client.responses.create(
    model="gpt-5",
    instructions="Respond only with a horoscope generated by a tool.",
    tools=tools,
    input=input_list,
)

print(final.output_text)
```

### JavaScript / TypeScript

```js
import OpenAI from "openai";
const openai = new OpenAI();

const tools = [
  {
    type: "function",
    name: "get_horoscope",
    description: "Get today's horoscope for an astrological sign.",
    parameters: {
      type: "object",
      properties: {
        sign: { type: "string", description: "e.g. Taurus, Aquarius" },
      },
      required: ["sign"],
      additionalProperties: false
    },
    strict: true,
  },
];

let input = [{ role: "user", content: "What is my horoscope? I am an Aquarius." }];

let response = await openai.responses.create({ model: "gpt-5", tools, input });

let functionCall = null;
let functionCallArguments = null;
input = input.concat(response.output);

response.output.forEach((item) => {
  if (item.type === "function_call") {
    functionCall = item;
    functionCallArguments = JSON.parse(item.arguments);
  }
});

function getHoroscope(sign) {
  return `${sign}: Next Tuesday you will befriend a baby otter.`;
}
const result = { horoscope: getHoroscope(functionCallArguments.sign) };

input.push({
  type: "function_call_output",
  call_id: functionCall.call_id,
  output: JSON.stringify(result),
});

const final = await openai.responses.create({
  model: "gpt-5",
  instructions: "Respond only with a horoscope generated by a tool.",
  tools,
  input,
});

console.log(final.output_text);
```

---

## 定义函数（工具）

函数定义写在每次请求的 `tools` 数组中：

- `type`：固定为 `"function"`  
- `name`：函数名（如 `get_weather`）  
- `description`：何时/如何使用该函数  
- `parameters`：**JSON Schema**，描述输入参数  
- `strict`：启用严格模式以确保参数**完全符合** Schema

示例：

```json
{
  "type": "function",
  "name": "get_weather",
  "description": "Retrieves current weather for the given location.",
  "parameters": {
    "type": "object",
    "properties": {
      "location": {
        "type": "string",
        "description": "City and country e.g. Bogotá, Colombia"
      },
      "units": {
        "type": "string",
        "enum": ["celsius", "fahrenheit"],
        "description": "Units the temperature will be returned in."
      }
    },
    "required": ["location", "units"],
    "additionalProperties": false
  },
  "strict": true
}
```

### 最佳实践（精简版）

1) **写清楚**函数名、参数、用途与返回语义；在系统提示中说明**何时用/不该用**。  
2) **工程化**设计：少用暧昧参数、用枚举/结构让非法状态不可表达。  
3) **能在代码里确定的参数别让模型填**；必要时合并固定串联的两个函数。  
4) **函数数量越少越准**；一般不超过 ~20 个同屏开放。  
5) 善用 **Playground** 生成/迭代 Schema；函数很多或难度高可考虑**微调**。

> **Token 成本**：工具定义会注入系统消息参与上下文与计费；尽量控制工具数量与描述长度。

---

## 处理函数调用

模型输出的 `response.output` 中，会包含 0..N 个 `function_call` 项：

```json
[
  {
    "id": "fc_12345xyz",
    "call_id": "call_12345xyz",
    "type": "function_call",
    "name": "get_weather",
    "arguments": "{\"location\":\"Paris, France\"}"
  },
  {
    "id": "fc_67890abc",
    "call_id": "call_67890abc",
    "type": "function_call",
    "name": "get_weather",
    "arguments": "{\"location\":\"Bogotá, Colombia\"}"
  },
  {
    "id": "fc_99999def",
    "call_id": "call_99999def",
    "type": "function_call",
    "name": "send_email",
    "arguments": "{\"to\":\"bob@email.com\",\"body\":\"Hi bob\"}"
  }
]
```

把每个调用都执行并把结果**逐一**追加回输入：

### Python

```python
import json

for tool_call in response.output:
    if tool_call.type != "function_call":
        continue
    name = tool_call.name
    args = json.loads(tool_call.arguments)

    result = call_function(name, args)  # 你实现的路由函数
    input_messages.append({
        "type": "function_call_output",
        "call_id": tool_call.call_id,
        "output": str(result)  # 文本或 JSON 字符串
    })
```

```python
def call_function(name, args):
    if name == "get_weather":
        return get_weather(**args)
    if name == "send_email":
        return send_email(**args)
    raise ValueError(f"Unknown function: {name}")
```

### JavaScript

```js
for (const toolCall of response.output) {
  if (toolCall.type !== "function_call") continue;

  const name = toolCall.name;
  const args = JSON.parse(toolCall.arguments);

  const result = await callFunction(name, args);
  input.push({
    type: "function_call_output",
    call_id: toolCall.call_id,
    output: result.toString()
  });
}

const callFunction = async (name, args) => {
  if (name === "get_weather") return getWeather(args.latitude, args.longitude);
  if (name === "send_email") return sendEmail(args.to, args.body);
  throw new Error(`Unknown function: ${name}`);
};
```

最终再次请求模型：

```js
const response2 = await openai.responses.create({
  model: "gpt-4.1",
  input,
  tools,
});
// 可能的最终文本：
// "It's about 15°C in Paris, 18°C in Bogotá, and I've sent that email to Bob."
```

---

## 进阶配置

### tool_choice（控制是否/如何调用）

- `"auto"`（默认）：0..N 次调用  
- `"required"`：至少调用一次  
- `{"type":"function","name":"get_weather"}`：**强制**调用且仅一次  
- **允许子集**：用 `"allowed_tools"` 限制能调用的工具集合（配合提示缓存省钱）

```json
{
  "tool_choice": {
    "type": "allowed_tools",
    "mode": "auto",
    "tools": [
      { "type": "function", "name": "get_weather" },
      { "type": "mcp", "server_label": "deepwiki" },
      { "type": "image_generation" }
    ]
  }
}
```

> 也可设置 `"none"` 模拟“无工具”。设置 `parallel_tool_calls: false` 可禁止并行多次调用。

### 严格模式（`strict: true`）

- 每个对象参数都要 `additionalProperties: false`。  
- `properties` 中的字段都必须被列入 `required`。  
- 伪可选参数可用 union：`["string","null"]`。

**开启严格模式：**

```json
{
  "type": "function",
  "name": "get_weather",
  "description": "Retrieves current weather for the given location.",
  "strict": true,
  "parameters": {
    "type": "object",
    "properties": {
      "location": { "type": "string" },
      "units": { "type": ["string","null"], "enum": ["celsius","fahrenheit"] }
    },
    "required": ["location","units"],
    "additionalProperties": false
  }
}
```

**关闭严格模式：**

```json
{
  "type": "function",
  "name": "get_weather",
  "description": "Retrieves current weather for the given location.",
  "parameters": {
    "type": "object",
    "properties": {
      "location": { "type": "string" },
      "units": {
        "type": "string", "enum": ["celsius","fahrenheit"]
      }
    },
    "required": ["location"]
  }
}
```

> 对首个使用某 Schema 的请求会有**额外延迟**（缓存后恢复正常）。

---

## 流式（Streaming）与事件

开启 `stream: true` 后可**实时看到**模型选择了哪个函数、如何逐步填参。

### Python

```python
from openai import OpenAI
client = OpenAI()

tools = [{
    "type": "function",
    "name": "get_weather",
    "description": "Get current temperature for a given location.",
    "parameters": {
        "type": "object",
        "properties": {
            "location": { "type": "string" }
        },
        "required": ["location"],
        "additionalProperties": False
    },
    "strict": True
}]

stream = client.responses.create(
    model="gpt-4.1",
    input=[{"role": "user", "content": "What's the weather like in Paris today?"}],
    tools=tools,
    stream=True
)

for event in stream:
    print(event)
```

### JavaScript

```js
import { OpenAI } from "openai";
const openai = new OpenAI();

const tools = [{
  type: "function",
  name: "get_weather",
  description: "Get current temperature for provided coordinates in celsius.",
  parameters: {
    type: "object",
    properties: { latitude: { type: "number" }, longitude: { type: "number" } },
    required: ["latitude","longitude"],
    additionalProperties: false
  },
  strict: true
}];

const stream = await openai.responses.create({
  model: "gpt-4.1",
  input: [{ role: "user", content: "What's the weather like in Paris today?" }],
  tools,
  stream: true,
  store: true,
});

for await (const event of stream) console.log(event);
```

**事件片段**（示意）：

```
{"type":"response.output_item.added","response_id":"resp_...","output_index":0,"item":{"type":"function_call","id":"fc_...","call_id":"call_...","name":"get_weather","arguments":""}}
{"type":"response.function_call_arguments.delta","response_id":"resp_...","item_id":"fc_...","output_index":0,"delta":"{\"location\":\"Paris, France\"}"}
{"type":"response.function_call_arguments.done","response_id":"resp_...","item_id":"fc_...","output_index":0,"arguments":"{\"location\":\"Paris, France\"}"}
{"type":"response.output_item.done","response_id":"resp_...","output_index":0,"item":{...}}
```

**聚合增量参数**：

```python
final_tool_calls = {}

for event in stream:
    if event.type == 'response.output_item.added':
        final_tool_calls[event.output_index] = event.item
    elif event.type == 'response.function_call_arguments.delta':
        index = event.output_index
        if final_tool_calls.get(index):
            final_tool_calls[index].arguments = (final_tool_calls[index].arguments or "") + event.delta
```

```js
const finalToolCalls = {};

for await (const event of stream) {
  if (event.type === "response.output_item.added") {
    finalToolCalls[event.output_index] = event.item;
  } else if (event.type === "response.function_call_arguments.delta") {
    const index = event.output_index;
    if (finalToolCalls[index]) {
      finalToolCalls[index].arguments = (finalToolCalls[index].arguments ?? "") + event.delta;
    }
  }
}
```

---

## 自定义工具（Custom Tools）

无需 JSON Schema；模型给你的工具**返回一段自由文本**作为输入。适合：避免嵌套 JSON、或用**语法/文法**约束输入。

### 示例

#### Python

```python
from openai import OpenAI
client = OpenAI()

resp = client.responses.create(
    model="gpt-5",
    input="Use the code_exec tool to print hello world to the console.",
    tools=[
        {"type": "custom", "name": "code_exec", "description": "Executes arbitrary Python code."}
    ]
)
print(resp.output)
```

#### JavaScript

```js
import OpenAI from "openai";
const client = new OpenAI();

const resp = await client.responses.create({
  model: "gpt-5",
  input: "Use the code_exec tool to print hello world to the console.",
  tools: [{ type: "custom", name: "code_exec", description: "Executes arbitrary Python code." }],
});

console.log(resp.output);
```

模型会返回一个 `custom_tool_call`，其 `input` 为**纯文本**，例如 `print("hello world")`。

---

## 语法约束（Context‑Free Grammars, CFG）

自定义工具可用 **grammar** 参数对模型给工具的**文本输入**做强约束。支持语法：

- **Lark**（简化子集）  
- **Regex**（Rust regex 语法；不支持 lookaround 与懒惰量词）

### Lark 例子

```python
grammar = '''
start: expr
expr: term (SP ADD SP term)* -> add | term
term: factor (SP MUL SP factor)* -> mul | factor
factor: INT
SP: " "
ADD: "+"
MUL: "*"
%import common.INT
'''

response = client.responses.create(
    model="gpt-5",
    input="Use the math_exp tool to add four plus four.",
    tools=[{
        "type": "custom",
        "name": "math_exp",
        "description": "Creates valid mathematical expressions",
        "format": { "type": "grammar", "syntax": "lark", "definition": grammar }
    }]
)
```

> **要点**（实践版）：
> - 词法器（lexer）**先于**语法器（parser）运行，贪婪匹配且最长优先。  
> - 需要在自由文本里“挖槽”时，尽量用**一个终结符**覆盖完整模式，而不是用多条规则拼。  
> - 规则（小写）用来**组合离散的终结符**，而不是“驱动”正则内部。  
> - 终结符正则要**边界清晰**、量词收敛；尽量避免无界 `.*`。

### Regex 例子

```python
grammar = r"^(?P<month>January|February|...|December)\\s+(?P<day>\\d{1,2})(?:st|nd|rd|th)?\\s+(?P<year>\\d{4})\\s+at\\s+(?P<hour>0?[1-9]|1[0-2])(?P<ampm>AM|PM)$"

response = client.responses.create(
    model="gpt-5",
    input="Use the timestamp tool to save a timestamp for August 7th 2025 at 10AM.",
    tools=[{
        "type": "custom",
        "name": "timestamp",
        "description": "Saves a timestamp in date + time in 24-hr format.",
        "format": { "type": "grammar", "syntax": "regex", "definition": grammar }
    }]
)
```

**限制**（两类语法共同点）：语法越简单越稳；避免巨型/含多层 `%ignore` 的语法；必要时收紧语法并在提示中给**few-shot**。

---

## 常见陷阱与提示

- **Schema 未缓存首次慢**：相同 Schema 后续命中缓存恢复正常。  
- **严格模式与并行**：某些快照/细节下并行多调用可能导致严格模式自动降级（参考模型快照说明）。  
- **拒答与过滤**：如因安全/过滤导致**不完整**或**refusal**，API 响应里会给出原因字段；你的应用需显式处理。

---

> 以上为经整理的开发要点与片段，便于直接落地集成。保留关键 API 字段、事件类型与代码骨架，去除了站点侧边栏与杂项文案。
